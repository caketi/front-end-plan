# JS 作用域补充

在 [JS作用域](https://github.com/nightn/front-end-plan/blob/master/js/js-scope.md) 这篇文章中，我们详细阐述了与 JS 作用域相关的概念：

-  执行上下文（Excutation Context, EC）
- 变量对象（Variable Object, VO）、活动对象（Activation Object, AO）
- 作用域链（Scope Chain）
- this
- JS 代码的编译阶段和执行阶段

并通过实例对 JS 代码的执行过程进行了分析，最后从执行上下文的角度分析了声明提升、块级作用域等场景。这篇文章是对其的进一步补充，并不是系统地阐述，而是采用问答的形式对各个知识点逐一补充。如有遗漏或错误，欢迎在 issue 中指出。

---

### 什么是变量对象（VO）？

**变量对象（Variable Object, VO）**是与特定执行上下文相关的特殊对象，它存储了

- 变量（通过 `var` 声明的变量，VariableDeclaration）
- 函数声明（FunctionDeclaration, FD）
- 函数形参

我们在写代码的时候会声明很多变量和函数，解释器如何去查找这些变量和函数呢？这便是通过变量对象完成的，

变量对象是 ES3 的概念，ES5 使用了**词法作用域模型（lexical environments model）**取而代之。

我们常常还听到活动对象（Activation Object, AO）的概念，**那么 VO 和 AO 有什么区别呢？**



### VO 和 AO 的区别？

我觉得，**VO 是一种更加宽泛的概念**，所谓变量对象，顾名思义，就是存储了当前执行环境中声明的所有变量（此处的变量可以理解为广义上的变量，即包括 `var` 声明的变量、函数声明、函数形参等），**而 AO 是 VO 的一种特殊形式**。**VO 是针对所有种类的执行上下文来讲的，而 AO 仅相对于函数执行上下文来说的**。



### 我们可以直接访问 VO 吗？

变量对象是 ES 词法作用域实现层面的概念，一般来说，我们不能直接访问，但又不能一概而论。**全局执行上下文（Global Excutation Context, GlobalEC）的变量对象是可以直接访问的，因为全局执行上下文的变量对象就是全局对象**。**而函数执行上下文的变量对象（即 AO）是不能直接访问的**，它是 ES 引擎的内部实现。

但从对概念的理解角度来看，我们可以认为 AO 也是普通的对象，最大的区别在于：**AO 没有原型**。



### 执行上下文、执行上下文栈

ES 代码根据其执行环境的不同可以分为 3 类：**Global code, Function code 和 Eval code**。这 3 类代码对应 3 类不同的执行上下文。ES 代码执行时，有一个执行上下文栈（Excutation Context Stack，或者叫做函数调用栈 Call Stack），最开始栈是空的，**在程序开始执行时，全局执行上下文便入栈了，随着函数的调用，会有函数执行上下文入栈，当一个函数返回时，其对应的函数执行上下文会出栈，Eval 代码的执行和结束也会触发执行上下文的入栈和出栈（具体后面会详述）**。栈顶的执行上下文永远是当前激活的执行上下文，栈底是全局执行上下文。随着全局代码（Global code）全部执行结束，全局执行上下文也出栈了，此时栈便空了。另外，我们经常碰到**栈溢出（Stack Overflow）**错误，其实指的就是执行上下文栈，当我们不断的递归调用某个函数，而又不提供递归出口的时候，就是不断地有新的函数执行上下文入栈，最终导致栈溢出。

**这里多说一点关于 ES 的事件循环（Event Loop）**。其实 Event Loop 并不是 ES 这门语言所提供的（也就是说，ES 规范并没有提供事件循环的描述），它是 ES 的宿主环境所提供的。**ES 仅提供了一个堆（堆内存）和一个栈（函数调用栈）**。而 ES 的宿主环境还提供了**一个队列（Callback Queue，回调队列）**。简单来讲，这个回调队列存放就是等待执行的回调函数。比如 setTimeout 的定时回调函数、AJAX 请求成功回调函数、button 点击事件处理函数等等。这些回调函数在特定事件触发时会立刻入队（比如定时结束、响应获取成功、按钮被点击），**注意：是立刻入队、而不是立刻执行**。

**那么 Callback Queue 中的回调函数在什么时候才会被执行呢？**

简单来说，当执行上下文栈为空时，Event Loop 便会将 Callback Queue 中的第一个回调函数出队并执行，此时就如同普通函数执行一样，创建执行上下文并入栈。当执行上下文栈再次为空时，Event Loop 将再次将 Callback Queue **当前**第一个回调函数出队并执行，以此类推，直至回调队列为空。

**严格来讲，Callback Queue 存放的并不是函数，而是消息，所以 Callback Queue 也可以称为消息队列。每个消息都有一个为了处理这个消息相关联的函数，该函数调用时将对应的消息作为输入参数。**



### 执行上下文在哪些情况下会出栈？

- 对于函数执行上下文，函数返回后，对应的执行上下文便会出栈。
- 对于 Eval 代码，当 Eval 代码执行结束后，其所对应的执行上下文会出栈。
- ES 作为单线程语言，当全局代码全部执行完毕时，全局执行上下文就会出栈。

除了以上情况，还有一些不容易想到的情况：

- 当代码抛出异常，却没有捕获时，可能造成一个或多个执行上下文出栈。



### Eval 代码的执行上下文是怎么样的？

对于全局执行上下文和函数执行上下文，它们都是由变量对象、作用域链和 this 组成。**然而，对于 Eval 执行上下文，它包括了执行上下文本身，还包括了 eval 函数调用时所处的调用上下文（Calling Context）**，举个例子：

```javascript
eval('var x = 42');
console.log(x);      // 42
```

如果 eval 执行上下文和其他上下文行为一致，那么此处 x 应该无法访问。假如我们将执行上下文栈记作 `ECStack` ，那么：

```javascript
// eval('var x = 42')
ECStack.push({
    context: evalEC,
    callingContext: globalEC
});
// eval exit
ECStack.pop();
```

**注意，在 eval 中声明的变量，影响的是其 `callingContext` 。**在此即全局执行环境，所以当 eval 执行结束后，在全局依然可以访问 x。

> 不过，在 ES5 严格模式下，eval 代码不会影响 callingContext。

另外，还有一点需要注意。eval 代码中的 `var` 声明并不会让这个属性的 [[Configurable]] 特性为 true。举个例子：

```javascript
// global code
var a = 42;
delete a;    // false
a;           // true

// eval code
eval('var b = 10;');
delete b;    // true
b;           // b is not defined
```

可以看出，在全局代码或函数代码中使用 `var` 声明的变量，是不能用 delete 删除的。想一想为什么呢？这些用 `var` 声明的变量，实际上也是属性（比如在浏览器环境中，全局代码用 `var` 声明的变量就是全局对象的属性），我们不能删除一个属性，是因为这个属性的 4 大特性之一：[[Configurable]] 被设置为了 false。而反观 eval，它声明的 b 虽然影响了 callingContext（此处即 globalEC），但我们依然可以使用 delete 将其删除，说明 b 的 [[Configurable]] 特性被设置为了 true。

> 总结一下：eval 代码的执行会创建新的执行上下文，但不同的是，代码中的声明影响的是 callingContext。另外，eval 中使用 var 声明的变量是可以被删除的，因为它的 [[Configurable]] 特性被设置为了 true。



